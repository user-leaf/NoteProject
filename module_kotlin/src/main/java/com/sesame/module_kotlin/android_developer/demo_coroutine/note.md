### 协程
协程是一种并发设计模式，您可以在 Android 平台上使用它来简化异步执行的代码。提高了工作效率。
所有协程都必须在一个作用域内运行。一个 CoroutineScope 管理一个或多个相关的协程。
所有 suspend 函数都必须在协程中执行。

#### 查漏补缺：
1、【我】利用withContext()调度线程，来确保每个函数都是主线程安全的。这样就可以在主线程任意调用函数，不必考虑应该使用哪个线程来执行函数了。
当需要确保主线程安全时，应始终在suspend函数内使用withContext()。
2、“不过请注意，即使我们没有调用 awaitAll()，coroutineScope 构建器也会等到所有新协程都完成后才恢复名为 fetchTwoDocs 的协程。”
3、CoroutineScope。可以创建自己的CoroutineScope。【我】协程作用域？是的，创建一个协程作用域。在协程作用域内才能通过launch/async创建一个协程。
已取消的作用域无法再创建协程。因此，仅当控制其生命周期的类被销毁时，才应调用 scope.cancel()。使用 viewModelScope 时，ViewModel 类会在 ViewModel 的 onCleared() 方法中自动为您取消作用域。
4、使用 launch 或 async 创建的每个协程都会返回一个 Job 实例，该实例是相应协程的唯一标识并管理其生命周期。


#### Q&A：
1、「通常，您应使用 launch 从常规函数启动新协程，因为常规函数无法调用 await。」
【我】问了一下。常规函数指的是非suspend函数。launch需要的是CoroutineScope，不需要在suspend里面，await需要在suspend fun 里面。

2、什么叫并行分解？--不懂这个概念，不管它了。【我】大概是这个意思，一个任务分成两个，然后并行执行。
3、「在 suspend 函数启动的所有协程都必须在该函数返回结果时停止，因此您可能需要保证这些协程在返回结果之前完成。」什么意思？
【我】需要保证所在函数在执行完毕前，该函数内的协程执行完毕。怎么保证？利用await()/awaitAll()
文中：“然后，您可以使用 await()（针对单个协程）或 awaitAll()（针对多个协程）保证这些协程在从函数返回结果之前完成。”


4、Q：launch启动一个协程，协程还没执行完，协程所在的函数就执行结束了，那怎么可以啊
A：因为协程中的挂起函数一般是异步的,异步就是这种特性。
就是这么设计的。。

5、我还想问。launch启动一个协程，协程还没执行完，协程所在的函数就执行结束了，然后协程也不继续执行了。。我试了一下，线程的话，尽管所在函数执行结束，但线程仍在执行直到执行结束。
可能我的协程作用域是viewmodel的，当函数执行完，自动把协程cancel了？
可能是我在main中执行的，而在android里页面在的话，在页面销毁前，协程会执行直到结束？
--是的，在Activity里试了一下，协程会执行完。
--在控制台，main()执行完，进程就结束了。大概与进程有关，进程都没了，协程所在的线程当然也没了，协程就不能继续执行了。不知道是不是。

6、怎么得到返回值。

7_1、协程作用域。
7_2、协程构建器。launch、async
coroutineScope也是？// 貌似是协程作用域，类似viewModelScope
7_3、协程调度程序。Dispatchers.Main/IO/Default。

8、怎么取消正在运行的协程？// 协程有个引用（Job实例，它是协程的唯一标识，可以用它来管理该协程的生命周期），要取消，可以通过Job实例调用cancel()

9、withContext()跟协程的关系。
【我】一般在suspend函数里用于切换线程，协程运行所在的线程。
「在 Kotlin 中，所有协程都必须在调度程序中运行，即使它们在主线程上运行也是如此。」
//【我】在启动一个协程时，launch()或者async()，都需要传递进去一个调度程序（Dispatchers.xxx）


#### 小结：
1、协程作用域
2、启动协程
3、withContext()
4、

