### android check


### 2.5 面向对象编程

##### 类与对象
File通常是用于编写Kotlin顶层函数和扩展函数的。

##### 继承与构造函数
Kotlin中默认所有非抽象类都不可以被继承。要可以被继承，类名前加open关键字。
加上open关键字，就是主动告诉kotlin编译器，这个类是专门为继承而设计的，这样该类就允许被继承了。

构造函数分为主构造函数和次构造函数，主构造函数没有函数体，要想像Java中那样在构造函数中初始化一些操作，可以在init结构体中去写。
构造函数中的参数可以全部声明成val。

继承。在主构造函数中声明成val或者var的参数将自动成为该类的字段，这样会导致和父类中的字段冲突。因此，参数前不用加任何关键字，让它的作用域仅限定在主构造函数中即可。

构造函数中的参数如果不加val/var，那么作用域就只限定在构造函数中。

在主构造函数中声明成val或者var的参数将自动成为该类的字段。

##### 接口
kotlin允许对接口中定义的函数进行默认实现

##### 函数的可见性修饰符
1. kotlin中默认用public修饰，没有加任何修饰符，默认是public。（Java中默认是default）。
2. kotlin中的protected修饰符，本类和子类可见，而非java中本类、子类、同一个包下可见。
3. internal修饰符，同一模块中的类可见

##### 数据类与单例类
1. 数据类 data关键字 加与不加不一样
2. 单例类 将class关键字改成object即可

### 2.6 Lambda编程

##### 集合的创建与遍历
for-in循环可以遍历区间，也可以用来遍历集合

listOf()函数创建的是不可变的集合，即无法对集合进行增删改操作;mutableListOf()函数是创建的是可变的集合。
同上，setOf()/mutableSetOf()。mapOf/mutableMapOf()及类似Java数组下标的访问方式[]
```kotlin
    val map = mapOf("aa" to 11, "bb" to 22, "cc" to 33)
    for ((name, age) in map) {
        println("$name == $age")
    }
```

### 2.7 空指针检查

##### 可空类型系统
Kotlin默认所有的参数和变量都不可为空。

判空辅助工具：
1. ?.操作符，当对象不为空时正常调用相应的方法，当对象为空时则什么都不做。
2. ?:操作符，操作符左右两边都接收一个表达式，如果左边表达式结果不为空则返回左边表达式的结果，为空则返回右侧表达式结果。
3. let函数，它可以处理全局变量判空问题，if解决不了。let函数将原始调用对象作为参数传递到Lambda表达式中。

let函数结合?.操作符可以在空指针检查时起到很大的作用：
```Kotlin
fun doStudy(study: Study?){
    study?.let{
        study.readBooks()
        study.doHomework()
    }
}
```
?.操作符表示对象为空时什么都不做，对象不为空时就调用let函数，而let函数会将study对象本身作为参数传递到Lambda表达式中，此时的study对象肯定不为空了。

当Lambda表达式的参数列表中只有一个参数时，可以不用声明参数名，直接使用it关键字来代替即可。

### 2.8 Kotlin中的小魔术

1. 给函数参数设定默认值可以在很大程度上替代次构造函数。

### 第3.7 静态方法
①工具类的实现，在Kotlin中非常推荐使用单例类的方式来实现。单例类的写法会将类中所有的方法全部变成类似于静态方法的调用方式。
②只让类中某一个方法变成类似静态方法的调用方式(写法)，使用companion object。
@JvmStatic注解只能加在单例类或companion object中的方法上。
③ 顶层方法是指那些没有定义在任何类中的方法，Kotlin编译器会将所有的顶层方法全部编译成静态方法，因此只要定义了一个顶层方法，就一定是一个静态方法。 
在Java中调用Helper.kt中的doSomething()顶层方法: HelperKt.doSomething(); 。Kotlin编译器会自动创建一个叫做HelperKt的Java类。

### 第6.5 Kotlin高阶函数
内联函数能抵消Lambda表达式带来的运行时开销。
将高阶函数声明成内联函数是一种好的编程习惯。绝大多数高阶函数是可以直接声明成内联函数的。
